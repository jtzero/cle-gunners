---
import { Image } from "astro:assets";
import { fromBase } from "@/lib/fromBase";
import { markdownify, slugify } from "@/lib/utils/textConverter";
import type { CollectionEntry } from "astro:content";
import ConditionalATag from "@/components/ConditionalATag.astro";
import type { PostType } from "@/content.types";
import Tile from "@/components/Tile.astro";
import Video from "@/components/Video.astro";

type Props = {
  post: CollectionEntry<"posts">;
  displayReadMore?: boolean;
  styling: string;
  headerStyling?: string;
  topBorderStyling?: string;
  heroTextStyling?: string;
};

const {
  post,
  displayReadMore = undefined,
  styling,
  topBorderStyling = "tile-default-top-border-style", // TODO: rename to topBorderClasses
  headerStyling = "",
  heroTextStyling = "",
} = Astro.props;

const showReadMore = (() => {
  if (displayReadMore !== undefined) {
    return displayReadMore;
  } else {
    return (post.data?.posts || []).length > 0;
  }
})();
const hasDynamicMedia =
  typeof post.data.imagePlacement !== "string" && post.data.imagePlacement;

const [width, height] = (post.data?.imageDimensions || "").split("x");
if (post.data?.imageDimensions) {
  post.data.parsedImageWidth = parseInt(width);
  post.data.parsedImageHeight = parseInt(height);
}
const [videoWidth, videoHeight] = (post.data?.videoDimensions || "").split("x");
if (post.data?.videoDimensions) {
  post.data.parsedVideoWidth = parseInt(videoWidth);
  post.data.parsedVideoHeight = parseInt(videoHeight);
}
const hasVideo = post.data?.video !== undefined;
const hasMultimedia = hasVideo || post.data.image;
const multimediaPlacement =
  post.data.imagePlacement || post.data.videoPlacement;
const hasHeaderMultimedia =
  hasMultimedia && (!multimediaPlacement || multimediaPlacement == "header");
const hasHeaderImage = post.data.image && hasHeaderMultimedia;
const hasTextBody = (post.body || "") != "";

const mediaClasses = (() => {
  if (hasDynamicMedia) {
    const bodyClass = (() => {
      if (!hasTextBody) {
        return "tile-body-with-only-body-media";
      } else {
        return "tile-body-with-body-media";
      }
    })();
    return Object.entries(post.data.imagePlacement).reduce(
      (acc, [key, value]) => {
        let mediaLabel = `${key}:`;
        if (key == "all") {
          mediaLabel = "";
        }
        if (value == "header") {
          acc["tile"] += ` ${mediaLabel}tile-image-with-header-media`;
          acc["headerMedia"] += ` ${mediaLabel}block`;
          acc["body"] += ` ${mediaLabel}tile-body-without-body-media`;
          acc["bodyMedia"] += ` ${mediaLabel}hidden`;
          acc["topBorderStyling"] += ` ${mediaLabel}no-top-border`;
        } else if (value == "body") {
          acc["tile"] += ` ${mediaLabel}tile-with-body-media`;
          acc["headerMedia"] += ` ${mediaLabel}hidden`;
          acc["body"] += ` ${mediaLabel}${bodyClass}`;
          acc["bodyMedia"] += ` ${mediaLabel}flex`;
          acc["topBorderStyling"] +=
            ` ${mediaLabel}tile-default-top-border-style`;
        }
        return acc;
      },
      {
        tile: "",
        body: "",
        bodyMedia: "",
        headerMedia: "",
        topBorderStyling: "",
        defaultTopBoardeBehaviour: false,
      },
    );
  } else {
    const tileBodyClass = (() => {
      if (hasHeaderMultimedia) {
        if (hasTextBody) {
          return "tile-body-without-body-media";
        } else {
          return "tile-body-without-body-media hidden";
        }
      } else if (hasMultimedia && multimediaPlacement == "body") {
        if (!hasTextBody) {
          return "tile-body-with-only-body-media";
        } else {
          return "tile-body-with-body-media";
        }
      } else {
        return "";
      }
    })();
    const tileWithHeaderMedia = (() => {
      if (width == height && !multimediaPlacement) {
        return "tile-with-square-header-media";
      } else if (hasHeaderMultimedia) {
        return "tile-with-header-media";
      } else {
        return "tile-with-body-media";
      }
    })();

    return {
      tile: tileWithHeaderMedia,
      topBorderStyling: hasHeaderMultimedia ? "" : topBorderStyling,
      defaultTopBoardeBehaviour: true,
      headerMedia: "",
      body: tileBodyClass,
      bodyMedia: "",
    };
  }
})();
---

<Tile
  id={slugify(post.data.title) || post.id}
  topBorderStyling={mediaClasses.topBorderStyling}
  defaultTopBoardeBehaviour={mediaClasses.defaultTopBoardeBehaviour}
  headerStyling={headerStyling}
  bodyStyling={`${heroTextStyling} ${mediaClasses.body}`}
  styling={`${styling} ${mediaClasses.tile}`}
>
  <Fragment slot="header">
    <span
      data-testid="post-header-media-container"
      class={mediaClasses.headerMedia}
    >
      {
        (hasHeaderImage || hasDynamicMedia) && (
          <ConditionalATag
            conditional={post.data.imageLink}
            href={post.data.imageLink}
          >
            <Image
              src={fromBase(post.data.image)}
              alt={post.data.imageAlt || post.data.title}
              width={post.data.parsedImageWidth}
              height={post.data.parsedImageHeight}
              class="tile-image h-auto w-full"
              format="webp"
            />
          </ConditionalATag>
        )
      }
      {
        hasVideo && !multimediaPlacement && (
          <Video
            url={post.data.video}
            width={post.data.parsedVideoWidth}
            height={post.data.parsedVideoHeight}
            title={post.data.title}
            orientation={post.data.videoOrientation}
          />
        )
      }
    </span>
  </Fragment>

  <Fragment slot="title">
    {
      post.data.title && (
        <h3 class={`${headerStyling} text-gold w-full pt-2 text-center`}>
          {post.data.title}
        </h3>
      )
    }
  </Fragment>

  <Fragment slot="body">
    <span
      data-testid="post-body-media-container"
      class={`flex ${mediaClasses.bodyMedia}`}
    >
      {
        hasVideo && (multimediaPlacement == "body" || hasDynamicMedia) && (
          <Video
            url={post.data.video}
            width={post.data.parsedVideoWidth}
            height={post.data.parsedVideoHeight}
            title={post.data.title}
            orientation={post.data.videoOrientation}
          />
        )
      }
      {/* TODO: the img is stretched ? */}
      {
        post.data.image &&
          (multimediaPlacement == "body" || hasDynamicMedia) && (
            <ConditionalATag
              conditional={post.data.imageLink}
              href={post.data.imageLink}
            >
              <Image
                src={fromBase(post.data.image)}
                alt={post.data.imageAlt || post.data.title}
                width={post.data.parsedImageWidth}
                height={post.data.parsedImageHeight}
                class="tile-image h-auto w-full"
                format="webp"
              />
            </ConditionalATag>
          )
      }
    </span>
    <span
      data-testid="tile-body-text"
      class={`flex flex-col items-center p-4 max-w-[100%] ${hasTextBody ? "" : "hidden"}`}
    >
      {
        /* TODO: there is waaay too much spacing from tile-body-text, hero text & p tag, the flex ? */
      }
      {
        hasTextBody && (
          <div
            class={`${heroTextStyling} tile-body-hero-text a-tag-underline text-center text-lg wrap-break-word`}
          >
            <Fragment set:html={markdownify(post.body!)} />
          </div>
        )
      }
      {
        showReadMore && (
          <a
            class="bg-primary align-center my-2 max-h-[2rem] max-w-[8rem] justify-self-center rounded-full px-5 text-white"
            href={fromBase(`/${post.id}`)}
          >
            Read More
          </a>
        )
      }
    </span>
  </Fragment>
</Tile>
<style>
  @import "@/components/Post.css";
  @reference "@/styles/tailwind.css";
  .tile-body-hero-text {
    max-width: 100%;
    white-space-collapse: preserve-breaks;
  }
  .tile-body-hero-text > :global(p) {
    max-width: 100%;
    white-space-collapse: preserve-breaks;
    white-space: pre-line;
  }
  .tile-with-square-header-media {
    @apply grid;
    grid-template-columns: 1fr;
    grid-template-rows: 1fr auto;
    height: auto;
    @variant sm {
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr;
      height: auto;
    }
  }
</style>
